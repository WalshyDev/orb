use http::Uri;
use http::header::{HeaderMap, SET_COOKIE};
use std::path::PathBuf;
use std::sync::RwLock;

/// A cookie jar that can optionally persist cookies to a file
pub struct CookieJar {
    /// Stored cookies as "name=value" pairs per domain
    cookies: RwLock<Vec<StoredCookie>>,
    file_path: Option<PathBuf>,
    /// Track if we need to save on drop
    modified: RwLock<bool>,
}

struct StoredCookie {
    domain: String,
    path: String,
    secure: bool,
    name: String,
    value: String,
}

impl CookieJar {
    pub fn new(file_path: Option<PathBuf>) -> Self {
        let mut cookies = Vec::new();

        // Load existing cookies from file if it exists
        if let Some(ref path) = file_path
            && path.exists()
            && let Ok(content) = std::fs::read_to_string(path)
        {
            for line in content.lines() {
                if line.starts_with('#') || line.trim().is_empty() {
                    continue;
                }
                if let Some(cookie) = parse_netscape_cookie_line(line) {
                    cookies.push(cookie);
                }
            }
        }

        Self {
            cookies: RwLock::new(cookies),
            file_path,
            modified: RwLock::new(false),
        }
    }

    /// Store cookies from Set-Cookie response headers
    pub fn store_response_cookies(&self, headers: &HeaderMap, uri: &Uri) {
        let host = uri.host().unwrap_or("");
        let path = uri.path();

        let mut cookies = self.cookies.write().unwrap_or_else(|e| e.into_inner());

        for cookie_header in headers.get_all(SET_COOKIE) {
            if let Ok(cookie_str) = cookie_header.to_str() {
                if let Some((name_value, _rest)) = cookie_str.split_once(';') {
                    if let Some((name, value)) = name_value.split_once('=') {
                        // Parse attributes (simplified)
                        let secure = cookie_str.to_lowercase().contains("secure");
                        let cookie_path = extract_cookie_attr(cookie_str, "path")
                            .unwrap_or_else(|| path.to_string());
                        let cookie_domain = extract_cookie_attr(cookie_str, "domain")
                            .unwrap_or_else(|| host.to_string());

                        cookies.push(StoredCookie {
                            domain: cookie_domain,
                            path: cookie_path,
                            secure,
                            name: name.trim().to_string(),
                            value: value.trim().to_string(),
                        });
                    }
                } else if let Some((name, value)) = cookie_str.split_once('=') {
                    // Simple cookie without attributes
                    cookies.push(StoredCookie {
                        domain: host.to_string(),
                        path: path.to_string(),
                        secure: false,
                        name: name.trim().to_string(),
                        value: value.trim().to_string(),
                    });
                }
            }
        }

        *self.modified.write().unwrap_or_else(|e| e.into_inner()) = true;
    }

    /// Save cookies to file (called on drop if file_path is set)
    pub fn save_to_file(&self) {
        let Some(ref path) = self.file_path else {
            return;
        };

        let cookies = self.cookies.read().unwrap_or_else(|e| e.into_inner());
        let mut content = String::from(
            "# Netscape HTTP Cookie File\n# https://curl.se/docs/http-cookies.html\n# This file was generated by orb\n\n",
        );

        for cookie in cookies.iter() {
            // Format: domain, flag, path, secure, expiry, name, value
            let domain_flag = if cookie.domain.starts_with('.') {
                "TRUE"
            } else {
                "FALSE"
            };
            let secure_flag = if cookie.secure { "TRUE" } else { "FALSE" };
            content.push_str(&format!(
                "{}\t{}\t{}\t{}\t0\t{}\t{}\n",
                cookie.domain, domain_flag, cookie.path, secure_flag, cookie.name, cookie.value
            ));
        }

        if let Err(err) = std::fs::write(path, content) {
            eprintln!(
                "Warning: Failed to write cookie jar '{}': {}",
                path.display(),
                err
            );
        }
    }
}

impl Drop for CookieJar {
    fn drop(&mut self) {
        if self.file_path.is_some() && *self.modified.read().unwrap_or_else(|e| e.into_inner()) {
            self.save_to_file();
        }
    }
}

/// Extract a cookie attribute value
fn extract_cookie_attr(cookie_str: &str, attr: &str) -> Option<String> {
    let attr_lower = attr.to_lowercase();

    for part in cookie_str.split(';') {
        let part_trimmed = part.trim();
        let part_lower = part_trimmed.to_lowercase();
        if part_lower.starts_with(&format!("{}=", attr_lower)) {
            return part_trimmed
                .split_once('=')
                .map(|(_, v)| v.trim().to_string());
        }
    }
    None
}

/// Parse a line from Netscape cookie file format
/// Format: domain\tflag\tpath\tsecure\texpiry\tname\tvalue
fn parse_netscape_cookie_line(line: &str) -> Option<StoredCookie> {
    let parts: Vec<&str> = line.split('\t').collect();
    if parts.len() < 7 {
        return None;
    }

    let domain = parts[0].to_string();
    let path = parts[2].to_string();
    let secure = parts[3] == "TRUE";
    let name = parts[5].to_string();
    let value = parts[6].to_string();

    Some(StoredCookie {
        domain,
        path,
        secure,
        name,
        value,
    })
}
